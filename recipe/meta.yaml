# The is a dummy recipe to debug the problem of failing tests when *cross-compiling* a
# package whose glib requirement is older than one of it's dependencies.
#
# e.g. downstream depends on glibc >=2.17, but libcufile depends on glibc >=2.27. At test
# time, downstream can load/run, but libcufile cannot because it requires a newer glibc than
# downstream.

package:
  name: downstream
  version: 1.0.0

source:
# The package consists of two test binaries one which prints "Hello, world!" and the other
# which tries to dlopen it's first argument.
  - path: test_load_elf.c
  - path: test_hello_world.c

build:
  number: 0

requirements:
  build:
    - {{ compiler('c') }}
    - {{ stdlib('c') }}
  host:
    - libcufile-dev 1.11.1.6

test:
  requires:
  # Adding a sysroot package to the test environment does not solve the problem. libcufile
  # still tries to load /lib64/libm.so.6 which is not the location of the sysroot package.
    - sysroot_{{ target_platform }} >=2.28  # [build_platform != target_platform]
  commands:
  # If we have cross-compiled, this binary should not be able to run on the host because it
  # is compiled for the target architecture. This means there is some emulation happening, but
  # it is not using the sysroot package in the test environment.
    - test_hello_world
  # Other libraries which depend on libc load properly
    - ldd ${PREFIX}/lib/libz.so.1  # [build_platform == target_platform]
    - test_load_elf ${PREFIX}/lib/libz.so.1
    - ldd ${PREFIX}/lib/libcufile.so.0  # [build_platform == target_platform]
    - test_load_elf ${PREFIX}/lib/libcufile.so.0
  # It must be that the emulator system is controled from elsewhere.
